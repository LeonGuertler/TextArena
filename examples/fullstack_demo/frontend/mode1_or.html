<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mode 1 OR - Operations Research Only</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6/dist/chart.umd.min.js"></script>
  <script src="/config.js"></script>
  <style>
    :root {
      --primary: #667eea;
      --primary-dark: #5568d3;
      --accent: #764ba2;
      --success: #27ae60;
      --surface: #ffffff;
      --surface-muted: #f7f8ff;
      --border-radius: 10px;
      --shadow: 0 6px 16px rgba(40, 51, 117, 0.12);
      --text-muted: #666666;
      --text-subtle: #9095a7;
    }
    * {
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #eef1ff 0%, #f7e9ff 100%);
      color: #1f2440;
    }
    header {
      background: var(--primary);
      color: var(--surface);
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.15);
    }
    header h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.3px;
    }
    header p {
      margin: 8px 0 0;
      font-size: 15px;
      opacity: 0.9;
    }
    main {
      max-width: 1260px;
      margin: 0 auto;
      padding: 28px 24px 48px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .panel {
      background: var(--surface);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      padding: 22px 24px;
    }
    .panel h2,
    .panel h3,
    .panel h4 {
      margin: 0;
      font-weight: 600;
    }
    .panel:not(:last-child) {
      margin-bottom: 4px;
    }
    label {
      display: block;
      margin-bottom: 10px;
      font-weight: 500;
    }
    .input-label {
      font-weight: 600;
      color: #2f3458;
    }
    input,
    textarea,
    button,
    select {
      width: 100%;
      padding: 12px;
      margin-top: 6px;
      border: 1px solid #d7daf1;
      border-radius: 8px;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      background: #fbfbff;
    }
    input:focus,
    textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
      background: #ffffff;
    }
    textarea {
      min-height: 100px;
      resize: vertical;
    }
    button {
      background: var(--primary);
      color: #ffffff;
      border: none;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.3px;
      transition: background 0.25s ease, transform 0.2s ease;
    }
    button:hover:not(:disabled) {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }
    button:disabled {
      background: #c8cdea;
      cursor: not-allowed;
    }
    button.ghost {
      width: auto;
      padding: 8px 18px;
      background: transparent;
      color: var(--primary);
      border: 1px solid var(--primary);
      border-radius: 999px;
      font-size: 13px;
    }
    button.ghost:disabled {
      color: #aeb4d9;
      border-color: #ccd1f4;
      background: transparent;
    }
    .game-layout {
      display: flex;
      flex-wrap: nowrap;
      gap: 24px;
      align-items: stretch;
    }
    .column {
      flex: 1 1 360px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: 320px;
      min-height: 100%;
    }
    .column-left {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .column-right {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .right-bottom-wrapper {
      display: flex;
      flex-direction: column;
      gap: 16px;
      flex: 1 1 auto;
      min-height: 0;
    }
    .news-section {
      background: #f6f7ff;
      border-radius: 12px;
      padding: 18px 20px;
      border: 1px solid #dfe2ff;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.65);
      display: flex;
      flex-direction: column;
      gap: 16px;
      flex: 0 0 230px;
      max-height: 240px;
      min-height: 220px;
      overflow: hidden;
    }
    .news-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
    }
    .news-header h3 {
      margin: 0;
      font-size: 18px;
      color: #2e3460;
    }
    .news-header span {
      font-size: 13px;
      color: var(--text-subtle);
    }
    .news-columns {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      flex: 1 1 auto;
      align-content: start;
      overflow-y: auto;
      padding-right: 6px;
    }
    .news-column {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .news-column h4 {
      margin: 0;
      font-size: 14px;
      color: #494f78;
      letter-spacing: 0.4px;
      text-transform: uppercase;
    }
    .news-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex: 1 1 auto;
    }
    .news-list .placeholder {
      padding: 18px 0;
    }
    .history-panel {
      background: #f1f3ff;
      border-radius: 12px;
      border: 1px solid #d5daf9;
      padding: 18px 20px;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.6);
      flex: 0 0 auto;
      min-height: 260px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .history-panel h3 {
      margin: 0;
      font-size: 17px;
      color: #2b2f53;
    }
    .history-list {
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
      padding-right: 6px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .history-entry {
      background: rgba(255, 255, 255, 0.75);
      border-radius: 10px;
      border: 1px solid rgba(102, 126, 234, 0.25);
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .history-entry header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
      font-weight: 600;
      color: #343a6f;
      font-size: 14px;
    }
    .history-entry header span {
      font-size: 12px;
      color: #2f3158;
      font-weight: 500;
    }
    .history-body {
      background: #fff;
      border-radius: 8px;
      border: 1px dashed rgba(102, 126, 234, 0.25);
      padding: 10px 12px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: #2f3158;
      white-space: pre-wrap;
      line-height: 1.45;
    }
    .history-placeholder {
      color: var(--text-subtle);
      font-style: italic;
      font-size: 14px;
    }
    .snapshot-panel {
      padding: 18px 20px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .snapshot-title {
      font-size: 18px;
      font-weight: 600;
      color: #242949;
      margin: 0 0 8px 0;
    }
    .snapshot-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .snapshot-box {
      background: var(--surface-muted);
      border-radius: 10px;
      padding: 14px 16px;
      border: 1px solid #dfe2ff;
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 70px;
    }
    .snapshot-label {
      font-size: 13px;
      color: #5f6275;
      font-weight: 500;
    }
    .snapshot-value {
      font-size: 20px;
      font-weight: 700;
      color: #161937;
    }
    .snapshot-subtext {
      font-size: 11px;
      color: #8a9099;
      font-style: italic;
      margin-top: 4px;
    }
    .snapshot-cost-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
      color: #5f6275;
      margin-top: 4px;
    }
    .snapshot-cost-info span {
      font-weight: 600;
      color: #2d3255;
    }
    .panel-title-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 16px;
    }
    .panel-title {
      font-size: 18px;
      color: #242949;
    }
    .panel-subtitle {
      font-size: 14px;
      color: var(--text-muted);
      margin: 6px 0 16px;
    }
    .algorithm-recommendation-section {
      margin-bottom: 20px;
    }
    .algorithm-recommendation-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .algorithm-recommendation-value {
      background: var(--surface-muted);
      border-radius: 8px;
      padding: 12px 14px;
      border: 1px solid #dfe2ff;
      font-size: 14px;
      color: #2d3152;
      min-height: 24px;
    }
    .algorithm-recommendation-value .placeholder {
      color: var(--text-subtle);
      font-style: italic;
    }
    .algorithm-recommendation-value .recommendation-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
    }
    .algorithm-recommendation-value .recommendation-item:not(:last-child) {
      border-bottom: 1px solid #e1e6ff;
      margin-bottom: 6px;
      padding-bottom: 8px;
    }
    .reasoning-section {
      margin-bottom: 20px;
    }
    .reasoning-text {
      background: #f4f6ff;
      border-radius: 8px;
      padding: 12px;
      line-height: 1.5;
      font-size: 14px;
      color: #2d3152;
      resize: vertical;
      cursor: default;
    }
    .reasoning-text:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
    }
    .order-decision-section {
      margin-bottom: 16px;
    }
    .conversation-log {
      max-height: 260px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-right: 4px;
    }
    .conversation-log .message {
      border-radius: 12px;
      padding: 12px 14px;
      line-height: 1.45;
      background: #eef1ff;
      border: 1px solid rgba(102, 126, 234, 0.2);
    }
    .conversation-log .message.user {
      background: #e7f4ff;
      border-color: rgba(66, 165, 245, 0.35);
    }
    .conversation-log .message-role {
      font-weight: 600;
      margin-bottom: 6px;
      color: #2b3054;
    }
    .conversation-log .message-body {
      font-size: 14px;
      color: #343652;
    }
    .news-card {
      width: 100%;
      background: #fef2ff;
      border-radius: 12px;
      padding: 14px 16px;
      border: 1px solid rgba(118, 75, 162, 0.25);
      box-shadow: 0 3px 10px rgba(118, 75, 162, 0.1);
    }
    .news-card.today {
      background: #fff6eb;
      border-color: rgba(255, 170, 43, 0.45);
    }
    .news-day {
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: #af58c8;
      margin-bottom: 6px;
    }
    .news-card.today .news-day {
      color: #d98200;
    }
    .news-text {
      font-size: 14px;
      color: #3b3052;
      line-height: 1.45;
    }
    .historical-charts-panel {
      padding: 20px 24px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .historical-demand-section,
    .historical-inventory-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .historical-demand-container {
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 20px;
      align-items: start;
    }
    .historical-inventory-container {
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 20px;
      align-items: start;
    }
    .historical-demand-chart-wrapper,
    .historical-inventory-chart-wrapper {
      position: relative;
      width: 100%;
      height: 300px;
    }
    .historical-demand-chart-wrapper canvas,
    .historical-inventory-chart-wrapper canvas {
      width: 100% !important;
      max-width: 100%;
      height: 100% !important;
    }
    .historical-demand-statistics {
      background: var(--surface-muted);
      border-radius: 12px;
      padding: 16px 18px;
      border: 1px solid #dfe2ff;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.6);
    }
    .historical-demand-statistics h4 {
      margin: 0 0 12px 0;
      font-size: 16px;
      color: #2c3053;
      font-weight: 600;
    }
    .statistics-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .statistic-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
    }
    .statistic-label {
      color: var(--text-muted);
      font-weight: 500;
    }
    .statistic-value {
      color: #2c3053;
      font-weight: 600;
      font-family: 'Courier New', monospace;
    }
    .decision-panel {
      padding: 16px 18px;
      margin-top: auto;
    }
    .decision-panel .panel-subtitle {
      margin-bottom: 12px;
    }
    .decision-panel .row {
      gap: 12px;
      margin-bottom: 8px;
    }
    .decision-panel button {
      margin-top: 4px;
    }
    .button-row {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-top: 12px;
    }
    .loading-text {
      font-size: 13px;
      color: var(--primary);
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .loading-text::before {
      content: "⏳";
      font-size: 14px;
    }
    .row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }
    .row > div {
      flex: 1 1 180px;
    }
    .error {
      color: #e74c3c;
      font-size: 13px;
      min-height: 18px;
    }
    .placeholder {
      color: var(--text-subtle);
      font-style: italic;
      font-size: 14px;
    }
    .transcript-panel {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .timeline {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 320px;
      overflow-y: auto;
      padding-right: 6px;
    }
    .timeline-entry {
      display: flex;
      gap: 12px;
      border-left: 3px solid rgba(118, 75, 162, 0.2);
      padding-left: 12px;
    }
    .timeline-entry .badge {
      font-size: 12px;
      font-weight: 600;
      color: #ffffff;
      background: var(--accent);
      border-radius: 999px;
      padding: 4px 10px;
      align-self: flex-start;
    }
    .timeline-entry .content {
      font-size: 13px;
      color: #2f3458;
      background: rgba(247, 248, 255, 0.95);
      border-radius: 8px;
      padding: 10px 12px;
      border: 1px solid rgba(118, 75, 162, 0.18);
      white-space: pre-wrap;
    }
    .raw-transcript {
      background: #1e1e1e;
      color: #d6f7c4;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      padding: 16px;
      border-radius: 8px;
      max-height: 320px;
      overflow-y: auto;
      white-space: pre-wrap;
      display: none;
    }
    .raw-transcript.visible {
      display: block;
    }
    .hidden {
      display: none !important;
    }
    @media (max-width: 960px) {
      header h1 {
        font-size: 24px;
      }
      main {
        padding: 20px 16px 36px;
      }
      .game-layout {
        flex-direction: column;
      }
      .column {
        min-width: 100%;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>📊 Mode 1 OR: Operations Research Only (Human Decision)</h1>
    <p>Use OR algorithm recommendations to make your final decision.</p>
  </header>

  <main>
    <section id="setup-section" class="panel">
      <h2>Game Setup</h2>
      <label class="input-label">Promised Lead Time (weeks)
        <input id="promised-lead-time" type="number" min="0" value="4" />
      </label>
      <button id="start-btn">Start Game</button>
      <div id="start-error" class="error"></div>
    </section>

    <section id="game-section" class="hidden">
      <div class="game-layout">
        <div class="column column-left">
          <section class="panel snapshot-panel" id="snapshot-panel">
            <h3 class="snapshot-title">Snapshot: <span id="snapshot-week">Week 1</span></h3>
            <div class="snapshot-grid">
              <div class="snapshot-box">
                <div class="snapshot-label">Last week's demand</div>
                <div class="snapshot-value" id="snapshot-last-demand">—</div>
              </div>
              <div class="snapshot-box">
                <div class="snapshot-label">Total Reward</div>
                <div class="snapshot-value" id="snapshot-total-reward">—</div>
              </div>
              <div class="snapshot-box">
                <div class="snapshot-label">On-hand inventory</div>
                <div class="snapshot-value" id="snapshot-on-hand">—</div>
                <div class="snapshot-subtext" id="snapshot-received"> </div>
              </div>
              <div class="snapshot-box">
                <div class="snapshot-label">In-transit Inventory</div>
                <div class="snapshot-value" id="snapshot-in-transit">—</div>
              </div>
            </div>
            <div class="snapshot-cost-info">
              <div>profit/unit: <span id="snapshot-profit">—</span></div>
              <div>holding cost/unit: <span id="snapshot-holding-cost">—</span></div>
            </div>
          </section>

          <section class="news-section">
            <div class="news-header">
              <h3>📰 News Outlook</h3>
              <span>Only this week’s and past headlines are visible to you and the AI.</span>
            </div>
            <div class="news-columns">
              <div class="news-column">
                <h4>This Week</h4>
                <div class="news-list" id="news-today">
                  <span class="placeholder">No news for this week.</span>
                </div>
              </div>
              <div class="news-column">
                <h4>History</h4>
                <div class="news-list history" id="news-past">
                  <span class="placeholder">No past news yet.</span>
                </div>
              </div>
            </div>
          </section>

          <section class="history-panel">
            <h3>📘 Game History</h3>
            <div id="history-list" class="history-list">
              <p class="history-placeholder">Game history will appear here once the simulation progresses.</p>
            </div>
          </section>
        </div>

        <div class="column column-right">
          <section class="panel decision-panel">
            <h3 class="panel-title">Order Decision</h3>
            
            <div class="algorithm-recommendation-section">
              <div class="algorithm-recommendation-header">
                <label class="input-label">OR Algorithm Recommendation</label>
              </div>
              <div id="algorithm-recommendation-value" class="algorithm-recommendation-value">
                <span class="placeholder">Waiting for AI recommendation...</span>
              </div>
            </div>

            <div class="reasoning-section hidden">
              <label class="input-label">Reasoning:</label>
              <textarea id="reasoning-text" readonly class="reasoning-text" placeholder="AI reasoning will appear here..."></textarea>
            </div>

            <div class="order-decision-section">
              <label class="input-label">Order decision:</label>
              <input id="order-quantity" type="number" min="0" placeholder="0" />
            </div>

            <div class="button-row">
              <button id="submit-decision-btn">SUBMIT</button>
              <span id="decision-loading" class="loading-text hidden">Submitting decision...</span>
            </div>
            <div id="decision-error" class="error"></div>
          </section>

          <section class="panel conversation-panel hidden">
            <h3 class="panel-title">Chat History</h3>
            <div id="conversation-log" class="conversation-log">
              <p class="placeholder">No messages yet.</p>
            </div>
            <label class="input-label">Your Message to AI Advisor
              <textarea id="user-message" placeholder="Ask questions, provide context, or discuss strategy with the AI..."></textarea>
            </label>
            <div class="button-row">
              <button id="send-message-btn">Send Message</button>
              <span id="chat-loading" class="loading-text hidden">AI is running...</span>
              <span id="chat-error" class="error"></span>
            </div>
          </section>
        </div>
      </div>

      <section id="historical-charts-panel" class="panel historical-charts-panel">
        <div class="historical-demand-section">
          <h3 class="panel-title">Historical Demand</h3>
          <div class="historical-demand-container">
            <div class="historical-demand-chart-wrapper">
              <canvas id="historical-demand-chart"></canvas>
            </div>
            <div class="historical-demand-statistics">
              <h4>Historical Demand Statistics</h4>
              <div class="statistics-content">
                <div class="statistic-item">
                  <span class="statistic-label">Average:</span>
                  <span class="statistic-value" id="demand-average">—</span>
                </div>
                <div class="statistic-item">
                  <span class="statistic-label">Standard deviation:</span>
                  <span class="statistic-value" id="demand-stddev">—</span>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="historical-inventory-section">
          <h3 class="panel-title">Historical Inventory Status</h3>
          <div class="historical-inventory-container">
            <div class="historical-inventory-chart-wrapper">
              <canvas id="historical-inventory-chart"></canvas>
            </div>
          </div>
        </div>
      </section>

      <section class="panel transcript-panel">
        <div class="panel-title-row">
          <h3 class="panel-title">📜 Detailed Transcript</h3>
          <button id="toggle-transcript-btn" class="ghost">View Raw Log</button>
        </div>
        <div id="timeline-list" class="timeline">
          <p class="placeholder">Timeline will appear once the game begins.</p>
        </div>
        <div id="raw-transcript" class="raw-transcript"></div>
      </section>
    </section>
  </main>

  <script>
    const supabaseClient = window.supabase.createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY);

    let currentRunId = null;
    let pollTimer = null;
    let latestProposalAction = null;

    const setupSection = document.getElementById("setup-section");
    const gameSection = document.getElementById("game-section");


    const newsTodayEl = document.getElementById("news-today");
    const newsPastEl = document.getElementById("news-past");
    const historyListEl = document.getElementById("history-list");

    const algorithmRecommendationEl = document.getElementById("algorithm-recommendation-value");
    const reasoningTextEl = document.getElementById("reasoning-text");

    const conversationLogEl = document.getElementById("conversation-log");
    const timelineListEl = document.getElementById("timeline-list");
    const rawTranscriptEl = document.getElementById("raw-transcript");
    const toggleTranscriptBtn = document.getElementById("toggle-transcript-btn");
    let showingRawTranscript = false;
    const historicalChartsPanel = document.getElementById("historical-charts-panel");
    const historicalDemandCanvas = document.getElementById("historical-demand-chart");
    const historicalInventoryCanvas = document.getElementById("historical-inventory-chart");
    const demandAverageEl = document.getElementById("demand-average");
    const demandStdDevEl = document.getElementById("demand-stddev");

    if (toggleTranscriptBtn) {
      toggleTranscriptBtn.addEventListener("click", () => {
        showingRawTranscript = !showingRawTranscript;
        toggleTranscriptBtn.textContent = showingRawTranscript ? "View Timeline" : "View Raw Log";
        if (timelineListEl) {
          timelineListEl.classList.toggle("hidden", showingRawTranscript);
        }
        if (rawTranscriptEl) {
          rawTranscriptEl.classList.toggle("visible", showingRawTranscript);
        }
      });
    }

    const startError = document.getElementById("start-error");
    const chatError = document.getElementById("chat-error");
    const decisionError = document.getElementById("decision-error");

    const userMessageInput = document.getElementById("user-message");
    const sendMessageBtn = document.getElementById("send-message-btn");
    const chatLoading = document.getElementById("chat-loading");
    const submitDecisionBtn = document.getElementById("submit-decision-btn");
    const decisionLoading = document.getElementById("decision-loading");
    const orderQuantityInput = document.getElementById("order-quantity");

    let historicalDemandChartInstance = null;
    let historicalInventoryChartInstance = null;
    let latestState = null;
    let isChatSubmitting = false;
    let isDecisionSubmitting = false;

    // Authentication guard
    supabaseClient.auth.getSession().then(({ data: { session } }) => {
      if (!session) {
        window.location.href = '/';
      }
    });

    document.getElementById("start-btn").addEventListener("click", async () => {
      startError.textContent = "";
      const promisedLeadTime = parseInt(document.getElementById("promised-lead-time").value, 10);

      try {
        const response = await apiRequest("/runs", {
          method: "POST",
          body: JSON.stringify({
            mode: "mode1_or",
            promised_lead_time: Number.isFinite(promisedLeadTime) ? promisedLeadTime : 4,
            enable_or: true,
          }),
        });
        currentRunId = response.run_id;
        setupSection.classList.add("hidden");
        gameSection.classList.remove("hidden");
        updateUI(response);
        startPolling();
      } catch (err) {
        startError.textContent = err.message || "Failed to start game";
      }
    });

    sendMessageBtn.addEventListener("click", async () => {
      if (isChatSubmitting) return;
      chatError.textContent = "";
      const message = userMessageInput.value.trim();
      if (!message) {
        chatError.textContent = "Please enter a message";
        return;
      }

      isChatSubmitting = true;
      updateChatControls();

      try {
        const response = await apiRequest(`/runs/${currentRunId}/messages`, {
          method: "POST",
          body: JSON.stringify({ message }),
        });
        userMessageInput.value = "";
        updateUI(response);
        startPolling();
      } catch (err) {
        chatError.textContent = err.message || "Failed to send message";
      } finally {
        isChatSubmitting = false;
        updateChatControls();
      }
    });

    submitDecisionBtn.addEventListener("click", async () => {
      if (isDecisionSubmitting) return;
      decisionError.textContent = "";
      const orderQuantity = orderQuantityInput.value.trim();

      if (orderQuantity === "") {
        decisionError.textContent = "Please enter order quantity";
        return;
      }

      const qty = parseInt(orderQuantity, 10);

      if (!Number.isInteger(qty) || qty < 0) {
        decisionError.textContent = "Please enter a valid whole number (0 or greater)";
        return;
      }

      const actionJson = JSON.stringify({
        "chips(Regular)": qty,
      });

      isDecisionSubmitting = true;
      updateDecisionControls();

      try {
        const response = await apiRequest(`/runs/${currentRunId}/final-action`, {
          method: "POST",
          body: JSON.stringify({ action_json: actionJson }),
        });
        orderQuantityInput.value = "";
        updateUI(response);
        startPolling();
      } catch (err) {
        decisionError.textContent = err.message || "Failed to submit decision";
      } finally {
        isDecisionSubmitting = false;
        updateDecisionControls();
      }
    });

    function updateUI(state) {
      if (!state) return;
      latestState = state;
      renderSnapshot(state);
      renderNews(state.news || {});
      renderHistory(state.daily_logs || []);
      renderORRecommendation(state.or_recommendation);
      renderConversation(state.conversation || []);
      renderTranscript(state.transcript || []);
      renderHistoricalCharts(state.daily_logs || [], state.current_day || 1);

      const completed = !!state.completed;
      if (completed && pollTimer) {
        clearInterval(pollTimer);
        pollTimer = null;
      }
      updateChatControls();
      updateDecisionControls();
      requestAnimationFrame(syncColumnHeights);
    }

    function renderSnapshot(state) {
      const snapshotWeekEl = document.getElementById("snapshot-week");
      const snapshotLastDemandEl = document.getElementById("snapshot-last-demand");
      const snapshotTotalRewardEl = document.getElementById("snapshot-total-reward");
      const snapshotOnHandEl = document.getElementById("snapshot-on-hand");
      const snapshotInTransitEl = document.getElementById("snapshot-in-transit");
      const snapshotReceivedEl = document.getElementById("snapshot-received");
      const snapshotProfitEl = document.getElementById("snapshot-profit");
      const snapshotHoldingCostEl = document.getElementById("snapshot-holding-cost");

      if (!snapshotWeekEl) return;

      const currentWeek = state.current_day || 1;
      snapshotWeekEl.textContent = `Week ${formatNumber(currentWeek)}`;

      // Last week's demand (previous day's requests)
      const dailyLogs = state.daily_logs || [];
      const lastWeekLog = dailyLogs.find(log => log.day === currentWeek - 1);
      let lastDemand = 0;
      if (lastWeekLog && lastWeekLog.requests) {
        lastDemand = Object.values(lastWeekLog.requests).reduce((sum, val) => sum + Number(val || 0), 0);
      }
      if (snapshotLastDemandEl) {
        snapshotLastDemandEl.textContent = formatNumber(lastDemand);
      }

      // Total Reward
      const reward = state.status_cards?.reward?.to_date || 0;
      if (snapshotTotalRewardEl) {
        snapshotTotalRewardEl.textContent = formatCurrency(reward);
      }

      // Inventory (single item now)
      const inventory = Array.isArray(state.status_cards?.inventory) ? state.status_cards.inventory : [];
      let item = inventory[0] || {};
      
      // Fallback: if inventory is empty or on_hand is missing (undefined), try to get from daily logs
      // Priority: current week's starting_inventory > previous week's ending_inventory
      // Note: 0 is a valid value, so we only use fallback if on_hand is undefined
      if ((!inventory.length || item.on_hand === undefined) && dailyLogs.length > 0) {
        // First try: current week's starting_inventory
        const currentWeekLog = dailyLogs.find(log => log.day === currentWeek);
        if (currentWeekLog && currentWeekLog.starting_inventory) {
          const itemIds = Object.keys(currentWeekLog.starting_inventory);
          if (itemIds.length > 0) {
            const firstItemId = itemIds[0];
            item = {
              ...item,
              on_hand: Number(currentWeekLog.starting_inventory[firstItemId] || 0),
            };
          }
        } else {
          // Second try: previous week's ending_inventory
          const previousWeekLog = dailyLogs.find(log => log.day === currentWeek - 1);
          if (previousWeekLog && previousWeekLog.ending_inventory) {
            const itemIds = Object.keys(previousWeekLog.ending_inventory);
            if (itemIds.length > 0) {
              const firstItemId = itemIds[0];
              item = {
                ...item,
                on_hand: Number(previousWeekLog.ending_inventory[firstItemId] || 0),
              };
            }
          }
        }
      }
      
      if (snapshotOnHandEl) {
        const onHandValue = item.on_hand !== undefined ? Number(item.on_hand) : 0;
        snapshotOnHandEl.textContent = formatNumber(onHandValue);
      }
      if (snapshotInTransitEl) {
        const inTransitValue = item.in_transit !== undefined ? Number(item.in_transit) : 0;
        snapshotInTransitEl.textContent = formatNumber(inTransitValue);
      }

      // Received this week (arrivals for current day)
      // Look for arrivals in the current week's daily log
      const currentWeekLog = dailyLogs.find(log => log.day === currentWeek);
      let receivedText = "";
      if (currentWeekLog && currentWeekLog.arrivals && typeof currentWeekLog.arrivals === "object") {
        const arrivals = currentWeekLog.arrivals;
        // Collect all arrivals from all items (supporting single item now, but extensible)
        const allReceivedItems = [];
        for (const itemId in arrivals) {
          if (arrivals.hasOwnProperty(itemId)) {
            const itemArrivals = arrivals[itemId];
            if (Array.isArray(itemArrivals) && itemArrivals.length > 0) {
              itemArrivals.forEach(entry => {
                const qty = Number(entry.quantity || entry[0] || 0);
                const orderWeek = Number(entry.order_day || entry[1] || 0);
                if (qty > 0 && orderWeek > 0) {
                  allReceivedItems.push(`${formatNumber(qty)} from week ${formatNumber(orderWeek)}`);
                }
              });
            }
          }
        }
        if (allReceivedItems.length > 0) {
          receivedText = `received this week: ${allReceivedItems.join(", ")}`;
        }
      }
      if (snapshotReceivedEl) {
        snapshotReceivedEl.textContent = receivedText;
      }

      // Cost info
      if (snapshotProfitEl) {
        snapshotProfitEl.textContent = formatCurrency(item.profit || 0);
      }
      if (snapshotHoldingCostEl) {
        snapshotHoldingCostEl.textContent = formatCurrency(item.holding_cost || 0);
      }
    }


    function renderNews(news) {
      fillNewsList(newsTodayEl, news.today, "No news for this week.", true);
      fillNewsList(newsPastEl, news.past, "No past news yet.");
    }

    function fillNewsList(container, items, emptyText, highlightToday = false) {
      if (!container) return;
      if (!Array.isArray(items) || !items.length) {
        container.innerHTML = `<span class="placeholder">${emptyText}</span>`;
        return;
      }

      container.innerHTML = items.map((item) => {
        const day = escapeHtml(String(item.day));
        const content = escapeHtml(String(item.content || "")).replace(/\n/g, "<br>");
        const todayClass = highlightToday ? "today" : "";
        return `
          <article class="news-card ${todayClass}">
            <div class="news-day">Week ${day}</div>
            <div class="news-text">${content}</div>
          </article>
        `;
      }).join("");
    }

    function renderHistory(dailyLogs) {
      if (!historyListEl) return;
      if (!Array.isArray(dailyLogs) || !dailyLogs.length) {
        historyListEl.innerHTML = `<p class="history-placeholder">Game history will appear here once the simulation progresses.</p>`;
        return;
      }

      const entries = dailyLogs
        .slice()
        .sort((a, b) => Number(a.day || 0) - Number(b.day || 0))
        .map((log) => createHistoryEntry(log))
        .join("");

      historyListEl.innerHTML = entries;
      historyListEl.scrollTop = historyListEl.scrollHeight;
      requestAnimationFrame(syncColumnHeights);
    }

    function createHistoryEntry(log) {
      const day = formatNumber(log.day);
      const reward = formatCurrency(log.daily_reward);
      const lines = buildHistoryLines(log);
      const body = escapeHtml(lines.join("\n"));
      return `
        <article class="history-entry">
          <header>
            <div>Week ${day}</div>
            <span>Reward ${reward}</span>
          </header>
          <div class="history-body">${body.replace(/\n/g, "<br>")}</div>
        </article>
      `;
    }

    function buildHistoryLines(log) {
      const lines = [`Week ${formatNumber(log.day)} concluded:`];
      const items = [];
      const seen = new Set();
      const appendItemsFrom = (source) => {
        if (!source) return;
        Object.keys(source).forEach((itemId) => {
          if (!seen.has(itemId)) {
            seen.add(itemId);
            items.push(itemId);
          }
        });
      };
      appendItemsFrom(log.orders);
      appendItemsFrom(log.requests);
      appendItemsFrom(log.sales);
      appendItemsFrom(log.starting_inventory);
      appendItemsFrom(log.ending_inventory);

      items.forEach((itemId) => {
        const ordered = Number((log.orders || {})[itemId] ?? 0);
        const starting = Number((log.starting_inventory || {})[itemId] ?? 0);
        const demand = Number((log.requests || {})[itemId] ?? 0);
        const sold = Number((log.sales || {})[itemId] ?? 0);
        const ending = Number((log.ending_inventory || {})[itemId] ?? 0);
        const arrivals = (log.arrivals && log.arrivals[itemId]) || [];
        const arrivalText =
          arrivals.length === 0
            ? "0"
            : arrivals
                .map((entry) => {
                  const qty = Number(entry.quantity ?? 0);
                  const orderDay = formatNumber(entry.order_day);
                  return `${qty} (ordered Week ${orderDay})`;
                })
                .join(", ");
        lines.push(
          `${itemId}: ordered=${ordered}, arrived=${arrivalText}, starting on-hand inventory=${starting}, demand=${demand}, sold=${sold}, ending on-hand inventory=${ending}`
        );
      });
      return lines;
    }

    function syncColumnHeights() {
      const leftCol = document.querySelector(".column-left");
      const rightCol = document.querySelector(".column-right");
      const historyPanelEl = document.querySelector(".history-panel");
      const historyList = document.querySelector(".history-list");
      if (!leftCol || !rightCol || !historyPanelEl || !historyList) return;

      // Let right column define overall height
      const layoutHeight = rightCol.getBoundingClientRect().height;
      leftCol.style.height = `${layoutHeight}px`;

      const leftTop = leftCol.getBoundingClientRect().top;
      const historyTop = historyPanelEl.getBoundingClientRect().top;
      const offset = historyTop - leftTop;
      const available = Math.max(layoutHeight - offset, 260);
      historyPanelEl.style.height = `${available}px`;

      const header = historyPanelEl.querySelector("h3");
      const headerHeight = header ? header.getBoundingClientRect().height : 0;
      const padding = parseFloat(window.getComputedStyle(historyPanelEl).paddingTop || "0") +
        parseFloat(window.getComputedStyle(historyPanelEl).paddingBottom || "0");
      const gap = parseFloat(window.getComputedStyle(historyPanelEl).gap || "0");
      const listHeight = Math.max(available - headerHeight - padding - gap, 160);
      historyList.style.maxHeight = `${listHeight}px`;
    }

    window.addEventListener("resize", () => {
      requestAnimationFrame(syncColumnHeights);
    });

    function renderORRecommendation(orRecommendation) {
      if (!algorithmRecommendationEl) return;
      
      if (!orRecommendation || typeof orRecommendation !== 'object') {
        algorithmRecommendationEl.innerHTML = '<span class="placeholder">Waiting for OR recommendation...</span>';
        latestProposalAction = null;
        orderQuantityInput.value = "";
        return;
      }

      const recommendations = orRecommendation.recommendations || {};
      const actionEntries = Object.entries(recommendations);
      
      latestProposalAction = actionEntries.length ? recommendations : null;

      if (actionEntries.length > 0) {
        algorithmRecommendationEl.innerHTML = actionEntries.map(([itemId, qty]) => `
          <div class="recommendation-item">
            <span>${escapeHtml(String(itemId))}</span>
            <strong>${formatNumber(qty)}</strong>
          </div>
        `).join("");
        
        // Automatically populate order quantity input with OR recommendation
        for (const [itemId, qty] of actionEntries) {
          const value = Number.isFinite(Number(qty)) ? Number(qty) : "";
          if (/regular/i.test(itemId)) {
            orderQuantityInput.value = value;
            break;
          } else if (/bbq/i.test(itemId)) {
            orderQuantityInput.value = value;
            break;
          }
        }
      } else {
        algorithmRecommendationEl.innerHTML = '<span class="placeholder">No OR recommendation yet.</span>';
        orderQuantityInput.value = "";
      }
    }

    function renderOrderDecision(transcript) {
      const proposal = findLatestProposal(transcript);
      
      // Render Algorithm recommendation
      if (!algorithmRecommendationEl) return;
      
      if (!proposal) {
        algorithmRecommendationEl.innerHTML = '<span class="placeholder">Waiting for AI recommendation...</span>';
        latestProposalAction = null;
        if (applyProposalBtn) applyProposalBtn.disabled = true;
        if (reasoningTextEl) reasoningTextEl.value = "";
        return;
      }

      const payload = coerceAgentPayload(proposal.content);
      const action = coerceActionObject(payload.action);
      const rationale = payload.rationale;

      const actionEntries = Object.entries(action);
      latestProposalAction = actionEntries.length ? action : null;
      if (applyProposalBtn) {
        applyProposalBtn.disabled = !actionEntries.length;
      }

      // Display algorithm recommendation (item name and quantity)
      if (actionEntries.length > 0) {
        algorithmRecommendationEl.innerHTML = actionEntries.map(([itemId, qty]) => `
          <div class="recommendation-item">
            <span>${escapeHtml(String(itemId))}</span>
            <strong>${formatNumber(qty)}</strong>
          </div>
        `).join("");
      } else {
        algorithmRecommendationEl.innerHTML = '<span class="placeholder">No explicit order proposal yet.</span>';
      }

      // Display reasoning (read-only)
      if (reasoningTextEl) {
        reasoningTextEl.value = rationale ? String(rationale) : "";
      }
    }

    function findLatestProposal(transcript) {
      if (!Array.isArray(transcript)) return null;
      for (let i = transcript.length - 1; i >= 0; i -= 1) {
        const event = transcript[i];
        if (event && event.kind === "agent_proposal" && event.payload) {
          return event.payload;
        }
      }
      return null;
    }

    function renderConversation(conversation) {
      if (!conversationLogEl) return;
      if (!Array.isArray(conversation) || !conversation.length) {
        conversationLogEl.innerHTML = `<p class="placeholder">No messages yet.</p>`;
        return;
      }

      const recent = conversation.slice(-12);
      conversationLogEl.innerHTML = recent.map((msg) => {
        const roleClass = msg.role === "human" ? "user" : "assistant";
        const roleLabel = msg.role === "human" ? "👤 You" : "🤖 AI Advisor";
        const content = formatConversationContent(msg);
        return `
          <div class="message ${roleClass}">
            <div class="message-role">${roleLabel}</div>
            <div class="message-body">${content}</div>
          </div>
        `;
      }).join("");

      conversationLogEl.scrollTop = conversationLogEl.scrollHeight;
    }

    function formatConversationContent(message) {
      const rawContent = message.content;
      if (message.role !== "human") {
        const parsed = coerceAgentPayload(rawContent);
        if (parsed && typeof parsed === "object") {
          const parts = [];
          if (parsed.rationale) {
            parts.push(`<strong>Rationale:</strong> ${escapeHtml(String(parsed.rationale)).replace(/\n/g, "<br>")}`);
          }
          const actionBlock = coerceActionObject(parsed.action);
          if (actionBlock && Object.keys(actionBlock).length) {
            parts.push(`<strong>Action:</strong> ${formatActionList(actionBlock)}`);
          }
          if (parsed.carry_over_insight) {
            parts.push(`<em>Carry-over insight:</em> ${escapeHtml(String(parsed.carry_over_insight)).replace(/\n/g, "<br>")}`);
          }
          if (parts.length) {
            return parts.join("<br><br>");
          }
        }
      }

      const content = tryExtractString(rawContent);
      if (!content) return "";
      try {
        const parsed = JSON.parse(content);
        if (parsed && typeof parsed === "object") {
          const parts = [];
          if (parsed.rationale) {
            parts.push(`<strong>Rationale:</strong> ${escapeHtml(String(parsed.rationale)).replace(/\n/g, "<br>")}`);
          }
          if (parsed.action && typeof parsed.action === "object") {
            parts.push(`<strong>Action:</strong> ${formatActionList(parsed.action)}`);
          }
          if (parts.length) {
            return parts.join("<br><br>");
          }
          return escapeHtml(JSON.stringify(parsed, null, 2)).replace(/\n/g, "<br>");
        }
      } catch (err) {
        // Not JSON, fall through
      }

      return escapeHtml(String(content)).replace(/\n/g, "<br>");
    }

    function formatActionList(actionObj) {
      const entries = Object.entries(actionObj || {});
      if (!entries.length) {
        return "<em>No action proposed.</em>";
      }
      return `
        <ul class="proposal-actions">
          ${entries.map(([key, value]) => `
            <li>
              <span>${escapeHtml(String(key))}</span>
              <strong>${formatNumber(value)}</strong>
            </li>
          `).join("")}
        </ul>
      `;
    }

    function renderTranscript(transcript) {
      if (!timelineListEl || !rawTranscriptEl) return;
      if (!Array.isArray(transcript) || !transcript.length) {
        timelineListEl.innerHTML = `<p class="placeholder">Timeline will appear once the game begins.</p>`;
        rawTranscriptEl.textContent = "Transcript will appear once the game begins.";
      } else {
        timelineListEl.innerHTML = transcript.map(createTimelineEntry).join("");
        const rawLines = transcript.map((evt) => {
          const label = String(evt.kind || evt.role || "event").toUpperCase();
          const payload = evt.payload ?? evt.message ?? evt.data ?? evt;
          return `[${label}]\n${JSON.stringify(payload, null, 2)}`;
        });
        rawTranscriptEl.textContent = rawLines.join("\n\n");
      }
      if (toggleTranscriptBtn) {
        toggleTranscriptBtn.textContent = showingRawTranscript ? "View Timeline" : "View Raw Log";
      }
      timelineListEl.classList.toggle("hidden", showingRawTranscript);
      rawTranscriptEl.classList.toggle("visible", showingRawTranscript);
    }

    function createTimelineEntry(event) {
      const kindLabel = escapeHtml(String(event.kind || event.role || "event").toUpperCase());
      const content = summarizeTimelineContent(event);
      return `
        <article class="timeline-entry">
          <span class="badge">${kindLabel}</span>
          <div class="content">${content}</div>
        </article>
      `;
    }

    function summarizeTimelineContent(event) {
      if (!event) return "";
      if (event.message) {
        return escapeHtml(tryExtractString(event.message)).replace(/\n/g, "<br>");
      }
      const payload = event.payload ?? event.data ?? event.details;
      if (typeof payload === "string") {
        return escapeHtml(payload).replace(/\n/g, "<br>");
      }
      if (payload && typeof payload === "object") {
        return escapeHtml(JSON.stringify(payload, null, 2)).replace(/\n/g, "<br>");
      }
      return escapeHtml(JSON.stringify(event, null, 2)).replace(/\n/g, "<br>");
    }

    function renderHistoricalCharts(dailyLogs, currentDay) {
      if (!historicalChartsPanel || !historicalDemandCanvas || !historicalInventoryCanvas) return;
      if (!Array.isArray(dailyLogs) || dailyLogs.length === 0) {
        if (historicalChartsPanel) historicalChartsPanel.style.display = "none";
        if (historicalDemandChartInstance) {
          historicalDemandChartInstance.destroy();
          historicalDemandChartInstance = null;
        }
        if (historicalInventoryChartInstance) {
          historicalInventoryChartInstance.destroy();
          historicalInventoryChartInstance = null;
        }
        return;
      }

      historicalChartsPanel.style.display = "block";

      // Filter logs: only include weeks up to currentDay - 1
      const filteredLogs = dailyLogs.filter((log) => log.day < currentDay);
      if (filteredLogs.length === 0) {
        if (historicalChartsPanel) historicalChartsPanel.style.display = "none";
        return;
      }

      // Ensure canvas dimensions
      ensureCanvasDimensions(historicalDemandCanvas);
      ensureCanvasDimensions(historicalInventoryCanvas);

      // Prepare data for Historical Demand chart
      const demandLabels = filteredLogs.map((log) => `Week ${formatNumber(log.day)}`);
      const demandData = filteredLogs.map((log) => {
        const requests = log.requests || {};
        return Object.values(requests).reduce((sum, value) => sum + Number(value || 0), 0);
      });
      const demandFulfilledData = filteredLogs.map((log) => {
        const sales = log.sales || {};
        return Object.values(sales).reduce((sum, value) => sum + Number(value || 0), 0);
      });

      // Calculate statistics
      const demandAverage = demandData.length > 0
        ? demandData.reduce((sum, val) => sum + val, 0) / demandData.length
        : 0;
      const demandVariance = demandData.length > 0
        ? demandData.reduce((sum, val) => sum + Math.pow(val - demandAverage, 2), 0) / demandData.length
        : 0;
      const demandStdDev = Math.sqrt(demandVariance);

      // Update statistics display
      if (demandAverageEl) {
        demandAverageEl.textContent = formatNumber(demandAverage, 1);
      }
      if (demandStdDevEl) {
        demandStdDevEl.textContent = formatNumber(demandStdDev, 1);
      }

      // Render Historical Demand chart
      if (historicalDemandChartInstance) {
        historicalDemandChartInstance.data.labels = demandLabels;
        historicalDemandChartInstance.data.datasets[0].data = demandData;
        historicalDemandChartInstance.data.datasets[1].data = demandFulfilledData;
        historicalDemandChartInstance.update();
        historicalDemandChartInstance.resize();
      } else if (window.Chart && historicalDemandCanvas.getContext) {
        historicalDemandChartInstance = new Chart(historicalDemandCanvas.getContext("2d"), {
          type: "bar",
          data: {
            labels: demandLabels,
            datasets: [
              {
                type: "line",
                label: "demand",
                data: demandData,
                borderColor: "#000000",
                backgroundColor: "transparent",
                borderWidth: 2,
                pointRadius: 4,
                pointBackgroundColor: "#000000",
                pointBorderColor: "#ffffff",
                pointBorderWidth: 1,
                tension: 0,
                order: 2,
              },
              {
                type: "bar",
                label: "demand fulfilled",
                data: demandFulfilledData,
                backgroundColor: "rgba(102, 126, 234, 0.6)",
                borderColor: "rgba(102, 126, 234, 0.8)",
                borderWidth: 1,
                order: 1,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: "index",
              intersect: false,
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "Units",
                },
                ticks: {
                  callback: (value) => formatNumber(value),
                },
                grid: {
                  color: "rgba(102, 126, 234, 0.15)",
                },
              },
              x: {
                grid: {
                  color: "rgba(102, 126, 234, 0.08)",
                },
              },
            },
            plugins: {
              legend: {
                display: true,
                position: "bottom",
                labels: {
                  usePointStyle: false,
                  generateLabels: (chart) => {
                    const original = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                    return original.map((label, index) => {
                      if (index === 0) {
                        // Line chart legend: show as line with point
                        label.fillStyle = "transparent";
                        label.strokeStyle = "#000000";
                        label.lineWidth = 2;
                        label.pointStyle = "circle";
                      } else if (index === 1) {
                        // Bar chart legend: show as rectangle
                        label.fillStyle = "rgba(102, 126, 234, 0.6)";
                        label.strokeStyle = "rgba(102, 126, 234, 0.8)";
                        label.lineWidth = 1;
                        label.pointStyle = "rect";
                      }
                      return label;
                    });
                  },
                },
              },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    const label = ctx.dataset.label || "";
                    const value = formatNumber(ctx.parsed.y);
                    return `${label}: ${value}`;
                  },
                },
              },
            },
          },
        });
      }

      // Prepare data for Historical Inventory Status chart
      const inventoryLabels = filteredLogs.map((log) => `Week ${formatNumber(log.day)}`);
      const onHandData = filteredLogs.map((log) => {
        const ending = log.ending_inventory || {};
        return Object.values(ending).reduce((sum, value) => sum + Number(value || 0), 0);
      });
      const orderData = filteredLogs.map((log) => {
        const orders = log.orders || {};
        return Object.values(orders).reduce((sum, value) => sum + Number(value || 0), 0);
      });

      // Build order status data for bar styling
      const orderStatusData = filteredLogs.map((log) => {
        const orderStatus = log.order_status || [];
        if (!orderStatus.length) {
          return { arrivalWeek: null };
        }
        let earliestArrivalDay = null;
        orderStatus.forEach((entry) => {
          const rawDay = entry.arrival_day ?? entry.arrival_week;
          const numericDay = Number(rawDay);
          if (Number.isFinite(numericDay)) {
            earliestArrivalDay = earliestArrivalDay === null
              ? numericDay
              : Math.min(earliestArrivalDay, numericDay);
          }
        });
        const arrivalWeek = earliestArrivalDay !== null ? Math.floor(earliestArrivalDay) : null;
        return { arrivalWeek };
      });

      const orderVisualStatus = orderStatusData.map((status) => {
        const arrivalWeek = Number.isFinite(status.arrivalWeek)
          ? Number(status.arrivalWeek)
          : null;
        const arrivedNow = arrivalWeek !== null && arrivalWeek < currentDay;
        const arrivingToday = arrivalWeek !== null && arrivalWeek === currentDay;
        return { arrived: arrivedNow, arrivalWeek, arrivingToday };
      });

      // Render Historical Inventory Status chart
      // Store orderStatusData in chart instance for tooltip access
      if (historicalInventoryChartInstance) {
        historicalInventoryChartInstance.data.labels = inventoryLabels;
        // Update line chart dataset (on-hand inventory)
        historicalInventoryChartInstance.data.datasets[0].data = onHandData;
        historicalInventoryChartInstance.data.datasets[0].borderColor = "#e74c3c";
        historicalInventoryChartInstance.data.datasets[0].pointBackgroundColor = "#e74c3c";
        // Update bar chart dataset (order)
        const barBackgrounds = orderVisualStatus.map((status) =>
          status.arrived ? "rgba(46, 204, 113, 0.6)" : "transparent"
        );
        const barBorders = orderVisualStatus.map(() => "rgba(46, 204, 113, 0.8)");
        historicalInventoryChartInstance.data.datasets[1].data = orderData;
        historicalInventoryChartInstance.data.datasets[1].backgroundColor = barBackgrounds;
        historicalInventoryChartInstance.data.datasets[1].borderColor = barBorders;
        historicalInventoryChartInstance.data.datasets[1].borderWidth = 2;
        // Store orderStatusData for tooltip access
        historicalInventoryChartInstance.orderStatusData = orderVisualStatus;
        historicalInventoryChartInstance.update();
        historicalInventoryChartInstance.resize();
      } else if (window.Chart && historicalInventoryCanvas.getContext) {
        historicalInventoryChartInstance = new Chart(historicalInventoryCanvas.getContext("2d"), {
          type: "bar",
          data: {
            labels: inventoryLabels,
            datasets: [
              {
                type: "line",
                label: "on-hand inventory",
                data: onHandData,
                borderColor: "#e74c3c",
                backgroundColor: "transparent",
                borderWidth: 2,
                pointRadius: 4,
                pointBackgroundColor: "#e74c3c",
                pointBorderColor: "#ffffff",
                pointBorderWidth: 1,
                tension: 0,
                order: 1, // Show line chart on top (lower order number = higher z-index)
              },
              {
                type: "bar",
                label: "order",
                data: orderData,
                backgroundColor: orderVisualStatus.map((status) =>
                  status.arrived ? "rgba(46, 204, 113, 0.6)" : "transparent"
                ),
                borderColor: orderVisualStatus.map(() => "rgba(46, 204, 113, 0.8)"),
                borderWidth: 2,
                borderSkipped: false,
                order: 2, // Show bar chart below line (higher order number = lower z-index)
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: "index",
              intersect: false,
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "Units",
                },
                ticks: {
                  callback: (value) => formatNumber(value),
                },
                grid: {
                  color: "rgba(102, 126, 234, 0.15)",
                },
              },
              x: {
                grid: {
                  color: "rgba(102, 126, 234, 0.08)",
                },
              },
            },
            plugins: {
              legend: {
                display: true,
                position: "bottom",
                labels: {
                  usePointStyle: false,
                  generateLabels: (chart) => {
                    const original = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                    const labels = [];
                    // First: on-hand inventory (line chart, red)
                    if (original[0]) {
                      const lineLabel = original[0];
                      lineLabel.fillStyle = "transparent";
                      lineLabel.strokeStyle = "#e74c3c";
                      lineLabel.lineWidth = 2;
                      lineLabel.pointStyle = "circle";
                      labels.push(lineLabel);
                    }
                    // Second: order (received) - green filled
                    if (original[1]) {
                      const receivedLabel = { ...original[1] };
                      receivedLabel.fillStyle = "rgba(46, 204, 113, 0.6)";
                      receivedLabel.strokeStyle = "rgba(46, 204, 113, 0.8)";
                      receivedLabel.lineWidth = 2;
                      receivedLabel.pointStyle = "rect";
                      receivedLabel.text = "order (received)";
                      labels.push(receivedLabel);
                    }
                    // Third: order (in-transit) - green border, transparent fill
                    if (original[1]) {
                      const inTransitLabel = { ...original[1] };
                      inTransitLabel.fillStyle = "transparent";
                      inTransitLabel.strokeStyle = "rgba(46, 204, 113, 0.8)";
                      inTransitLabel.lineWidth = 2;
                      inTransitLabel.pointStyle = "rect";
                      inTransitLabel.text = "order (in-transit)";
                      inTransitLabel.datasetIndex = -1;
                      labels.push(inTransitLabel);
                    }
                    return labels;
                  },
                },
              },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    const label = ctx.dataset.label || "";
                    const value = formatNumber(ctx.parsed.y);
                    if (ctx.datasetIndex === 1 && ctx.parsed.y > 0) {
                      const orderStatusData = ctx.chart.orderStatusData || [];
                      const status = orderStatusData[ctx.dataIndex];
                      if (status) {
                        if (status.arrived && status.arrivalWeek !== null) {
                          return `${label}: ${value} (received at week ${formatNumber(status.arrivalWeek)})`;
                        }
                        if (status.arrivalWeek !== null) {
                          if (status.arrivingToday) {
                            return `${label}: ${value} (arriving later today)`;
                          }
                          return `${label}: ${value} (expected week ${formatNumber(status.arrivalWeek)})`;
                        }
                      }
                      return `${label}: ${value} (in-transit)`;
                    }
                    return `${label}: ${value}`;
                  },
                },
              },
            },
          },
        });
        // Store orderStatusData for tooltip access
        historicalInventoryChartInstance.orderStatusData = orderVisualStatus;
      }
    }

    function buildLineChartOptions({ yLabel, tooltipLabel }) {
      return {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: "index",
          intersect: false,
        },
        scales: {
          y: {
            title: {
              display: !!yLabel,
              text: yLabel || "",
            },
            ticks: {
              callback: (value) => formatNumber(value),
            },
            grid: {
              color: "rgba(102, 126, 234, 0.15)",
            },
          },
          x: {
            grid: {
              color: "rgba(102, 126, 234, 0.08)",
            },
          },
        },
        plugins: {
          legend: {
            display: true,
            position: "bottom",
          },
          tooltip: {
            callbacks: {
              label: tooltipLabel,
            },
          },
        },
      };
    }

    function ensureCanvasDimensions(canvas) {
      if (!canvas) return;
      const desired = 300;
      const width = canvas.clientWidth || (canvas.parentElement ? canvas.parentElement.clientWidth : 480);
      canvas.height = desired;
      canvas.style.height = `${desired}px`;
      canvas.style.maxHeight = `${desired}px`;
      if (width > 0) {
        canvas.width = width;
        canvas.style.width = "100%";
      }
    }

    function startPolling() {
      if (pollTimer) clearInterval(pollTimer);
      pollTimer = setInterval(async () => {
        try {
          const state = await apiRequest(`/runs/${currentRunId}`, { method: "GET" });
          updateUI(state);
          if (state.completed || state.waiting_for_final_action) {
            clearInterval(pollTimer);
            pollTimer = null;
          }
        } catch (err) {
          console.error("Polling error:", err);
        }
      }, 2000);
    }

    async function apiRequest(path, options = {}) {
      const session = await supabaseClient.auth.getSession();
      if (!session.data.session) {
        window.location.href = '/';
        throw new Error("Not authenticated");
      }
      const token = session.data.session.access_token;
      const response = await fetch(path, {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        ...options,
      });
      if (!response.ok) {
        const text = await response.text();
        throw new Error(text || response.statusText);
      }
      return response.json();
    }

    function updateChatControls() {
      const completed = !!(latestState && latestState.completed);
      const disableSend = completed || isChatSubmitting;
      if (sendMessageBtn) sendMessageBtn.disabled = disableSend;
      if (userMessageInput) userMessageInput.disabled = completed || isChatSubmitting;
      if (chatLoading) chatLoading.classList.toggle("hidden", !isChatSubmitting);
    }

    function updateDecisionControls() {
      const completed = latestState ? !!latestState.completed : false;
      const waiting = latestState ? !!latestState.waiting_for_final_action : false;
      const disableSubmit = completed || !waiting || isDecisionSubmitting;
      const disableInputs = completed || isDecisionSubmitting;
      if (submitDecisionBtn) submitDecisionBtn.disabled = disableSubmit;
      if (orderQuantityInput) orderQuantityInput.disabled = disableInputs;
      if (decisionLoading) decisionLoading.classList.toggle("hidden", !isDecisionSubmitting);
    }

    updateChatControls();
    updateDecisionControls();

    function formatCurrency(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return "$0.00";
      return `$${num.toFixed(2)}`;
    }

    function formatUnitCurrency(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return "$0.00";
      return `$${num.toFixed(2)}`;
    }

    function formatNumber(value, decimals = 0) {
      const num = Number(value);
      if (!Number.isFinite(num)) return "—";
      return num.toLocaleString(undefined, {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals,
      });
    }

    function escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function tryExtractString(value) {
      if (value == null) return "";
      if (typeof value === "string") return value;
      if (typeof value === "object") return JSON.stringify(value);
      return String(value);
    }

    function coerceAgentPayload(content) {
      if (content && typeof content === "object" && !Array.isArray(content)) {
        return content;
      }
      const stringContent = tryExtractString(content);
      const parsed = tryParseJson(stringContent);
      if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
        return parsed;
      }
      return { rationale: stringContent };
    }

    function coerceActionObject(action) {
      if (action && typeof action === "object" && !Array.isArray(action)) {
        return action;
      }
      const actionStr = tryExtractString(action);
      const parsed = tryParseJson(actionStr);
      if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
        return parsed;
      }
      return {};
    }

    function tryParseJson(raw) {
      if (typeof raw !== "string") return null;
      let text = raw.trim();
      if (!text) return null;

      if (text.startsWith("```")) {
        text = text.replace(/^```(?:json)?/i, "").replace(/```$/i, "").trim();
      }
      if (/^json\s*/i.test(text)) {
        text = text.replace(/^json\s*/i, "");
      }

      const firstBrace = text.indexOf("{");
      const firstBracket = text.indexOf("[");
      let start = firstBrace;
      if (start === -1 || (firstBracket !== -1 && firstBracket < start)) {
        start = firstBracket;
      }
      if (start > 0) {
        text = text.slice(start);
      }

      const lastBrace = text.lastIndexOf("}");
      const lastBracket = text.lastIndexOf("]");
      let end = Math.max(lastBrace, lastBracket);
      if (end >= 0 && end < text.length - 1) {
        text = text.slice(0, end + 1);
      }

      try {
        return JSON.parse(text);
      } catch (err) {
        return null;
      }
    }
  </script>
</body>
</html>
